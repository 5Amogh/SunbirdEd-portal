/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
/* istanbul ignore next. Fabric extension - cannot be tested */

var content_editor = function() {};
content_editor.prototype.jQuery = window.$;
content_editor.prototype._ = window._;
window.org.ekstep.contenteditor = new content_editor();
window.org.ekstep.collectioneditor = new content_editor();
content_editor = undefined;

window.ServiceConstants = {
    SEARCH_SERVICE: "search",
    POPUP_SERVICE: "popup",
    CONTENT_SERVICE: "content",
    ASSESSMENT_SERVICE: "assessment",
    LANGUAGE_SERVICE: "language",
    META_SERVICE: "meta",
    ASSET_SERVICE: "asset",
    TELEMETRY_SERVICE: "telemetry"
}

window.ManagerConstants = {
    EVENT_MANAGER: "event",    
    PLUGIN_MANAGER: "plugin",
    RESOURCE_MANAGER: "resource"   
}
org.ekstep.contenteditor.config = {
    baseURL: '''',
    apislug: '/api',
    defaultSettings: 'config/editorSettings.json',
    build_number: 'BUILDNUMBER',
    pluginRepo: '/content-plugins',
    aws_s3_urls: ["https://s3.ap-south-1.amazonaws.com/ekstep-public-dev/", "https://ekstep-public-dev.s3-ap-south-1.amazonaws.com/"],
    corePluginMapping: {},
    baseConfigManifest: "config/baseConfigManifest.json",
    plugins: [
        { "id": "org.ekstep.preview", "ver": "1.0", "type": "plugin" },
        { "id": "org.ekstep.collectioneditor", "ver": "1.0", "type": "plugin" }
    ],
    corePluginsPackaged: false,
    dispatcher: "local",
    useProxyForURL: true
}

org.ekstep.contenteditor.baseConfigManifest = []
org.ekstep.collectioneditor.config = {
    plugins: [
      { "id": "org.ekstep.lessonbrowser", "ver": "1.0", "type": "plugin" },                
      { "id": "org.ekstep.textbookmeta", "ver": "1.0", "type": "plugin" },
      { "id": "org.ekstep.unitmeta", "ver": "1.0", "type": "plugin" },
      { "id": "org.ekstep.contentmeta", "ver": "1.0", "type": "plugin" },
      { "id": "org.ekstep.telemetry", "ver": "1.0", "type": "plugin" },
      { "id": "org.ekstep.collectionheader", "ver": "1.0", "type": "plugin" },
      { "id": "org.ekstep.toaster", "ver": "1.0", "type": "plugin" }
    ],
    dispatcher: "local"
}


org.ekstep.collectioneditor.cache = {
	nodesModified: {}
};
/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */

org.ekstep.contenteditor.init = function(context, config, $scope, $document, callback) {
    org.ekstep.contenteditor._mergeConfig(config);
    org.ekstep.contenteditor._initServices();
    org.ekstep.contenteditor.globalContext = context;    
    org.ekstep.contenteditor._loadDefaultPlugins(context, callback);
    //org.ekstep.contenteditor._backwardCompatibility();
}

org.ekstep.contenteditor._backwardCompatibility = function() {
    /* Deprecated variables */
    EkstepEditorAPI.apislug = org.ekstep.contenteditor.config.apislug;
    EkstepEditorAPI.baseURL = org.ekstep.contenteditor.config.baseURL;
    EkstepEditorAPI.absURL = org.ekstep.contenteditor.config.absURL;
    EkstepEditorAPI.globalContext = org.ekstep.contenteditor.globalContext;
}

org.ekstep.contenteditor._initServices = function() {
    org.ekstep.services.config = {
        baseURL: org.ekstep.contenteditor.config.baseURL,
        apislug: org.ekstep.contenteditor.config.apislug
    }
    org.ekstep.pluginframework.initialize({ 
        env: 'editor',
        jQuery: org.ekstep.contenteditor.jQuery, 
        pluginRepo: org.ekstep.contenteditor.config.pluginRepo,
        build_number: org.ekstep.contenteditor.config.build_number        
    });
}

org.ekstep.contenteditor._mergeConfig = function(config) {
    config = config || {};
    org.ekstep.contenteditor.config = _.assign(org.ekstep.contenteditor.config, config);
}

org.ekstep.contenteditor._loadDefaultPlugins = function(context, callback) {
    if(org.ekstep.contenteditor.config.corePluginsPackaged === true) org.ekstep.contenteditor.jQuery("body").append($("<script type='text/javascript' src='scripts/coreplugins.js?" + org.ekstep.contenteditor.config.build_number + "'>"));
    org.ekstep.pluginframework.eventManager.enableEvents = false;
    org.ekstep.pluginframework.pluginManager.loadAllPlugins(org.ekstep.contenteditor.config.plugins, undefined, function () {        
        org.ekstep.pluginframework.eventManager.enableEvents = true;
        callback();
    });
}
/**
 * The Content Editor API is the core interface of the plugins with the rest of the editor framework. It allows the plugins
 * to access the framework resources, launch popups, and handle events raised by the framework. Plugins should not call any
 * other framework classes directly.
 * 
 * @class org.ekstep.contenteditor.api
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
window.org.ekstep.contenteditor.api = {
    /**
     * Handle for JQuery. All plugins should use this instead of using '$' directly
     * 
     * @member {Object} jQuery
     * @memberof org.ekstep.contenteditor.api
     */
    jQuery: org.ekstep.contenteditor.jQuery,

    /**
     * Handle for Lodash Library. All plugins should use this instead of using '_' directly
     * 
     * @member {Object} _
     * @memberof org.ekstep.contenteditor.api
     */
    _: org.ekstep.contenteditor._,

    /**
     * Add an object to the context
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof org.ekstep.contenteditor.api
     */
    setContext: function(key, value) {
        org.ekstep.contenteditor.globalContext[key] = value;
    },

    /**
     * Get the context variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof org.ekstep.contenteditor.api
     */
    getContext: function(key) {
        return org.ekstep.contenteditor.globalContext[key];
    },

    /**
     * Get all context attributes
     * @return {map} Map of key values
     */
    getAllContext: function() {
        return org.ekstep.contenteditor.globalContext;
    },

    /**
     * Add or update a configuration property
     * 
     * @param {String} key   Key
     * @param {Object} value Value
     * @memberof org.ekstep.contenteditor.api
     */
    setConfig: function(key, value) {
        org.ekstep.contenteditor.config[key] = value;
    },

    /**
     * Get the config variable
     * 
     * @param  {String} key Key
     * @return {object}     Value
     * @memberof org.ekstep.contenteditor.api
     */
    getConfig: function(key) {
        return org.ekstep.contenteditor.config[key];
    },

    /**
     * Get all config attributes
     * @return {map} Map of key values
     */
    getAllConfig: function() {
        return org.ekstep.contenteditor.config;
    },

    /**
     * Register an event listener callback function for the events raised by the framework.
     * @param type {string} name of the event (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} callback function
     * @param scope {object} the scope of the callback (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    addEventListener: function(type, callback, scope) {
        org.ekstep.pluginframework.eventManager.addEventListener(type, callback, scope);
    },

    /**
     * Fires an event to the framework, allowing other plugins who may have registered to receive the callback notification. All
     * communication between the framework and other plugins is via the events.
     * @param type {string} name of the event to fire (e.g. org.ekstep.quickstart:configure)
     * @param data {object} event data to carry along with the notification
     * @param target {object} the scope of the event (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    dispatchEvent: function(type, data, target) {
        org.ekstep.pluginframework.eventManager.dispatchEvent(type, data, target);
    },

    /**
     * Remove an event listener to an event. Plugins should cleanup when they are removed.
     * @param type {string} name of the event registered with (e.g. org.ekstep.quickstart:configure)
     * @param callback {function} remove the callback function
     * @param scope {object} the scope of the event (use this)
     * @memberof org.ekstep.contenteditor.api
     */
    removeEventListener: function(type, callback, scope) {
        org.ekstep.pluginframework.eventManager.removeEventListener(type, callback, scope);
    },

    /**
     * Framework support to load plugin resources. When the resources are loaded, the callback is fired.
     * @param pluginId {string} id of the plugin requesting resource to be loaded
     * @param pluginVer {string} version of the plugin that is requesting the resource to be loaded
     * @param src {string} URL of the resource to be loaded
     * @param dataType {object} dataType of the resource (image, or audio)
     * @param callback {function} callback function whent he resource is available
     * @memberof org.ekstep.contenteditor.api
     */
    loadPluginResource: function(pluginId, pluginVer, src, dataType, callback) {
        org.ekstep.pluginframework.pluginManager.loadPluginResource(pluginId, pluginVer, src, dataType, callback);
    },

    /**
     * Returns the handle to the Angular services. The services can be used by plugisn to achieve
     * the functional calls or render custom views. Valid services are:
     *     popup - UI service to render popup
     *     content - Provides access to the content API (for loading templates and assets)
     *     assessment - Provides access to the assessment API (for loading questions)
     *     language - Provides access to the wordnet API (for loading words and aksharas)
     *     search - Provides access to search API (for search activities, question, domains)
     *     meta - Provides access to metadata API (for resource bundles, ordinals, definitions)
     *     asset - Provides access to the content API (for save assets)
     *     telemetry - Service to genarate and log telemetry events
     * @param serviceId {string} id of the service to return. Returns undefined if the id is invalid
     * @memberof org.ekstep.contenteditor.api
     */
    getService: function(serviceId) {
        var service = '';
        switch (serviceId) {
            case ServiceConstants.POPUP_SERVICE:
                service = org.ekstep.services.popupService;
                break;
            case ServiceConstants.CONTENT_SERVICE:
                service = org.ekstep.services.contentService;
                break;
            case ServiceConstants.ASSESSMENT_SERVICE:
                service = org.ekstep.services.assessmentService;
                break;
            case ServiceConstants.LANGUAGE_SERVICE:
                service = org.ekstep.services.languageService;
                break;
            case ServiceConstants.SEARCH_SERVICE:
                service = org.ekstep.services.searchService;
                break;
            case ServiceConstants.META_SERVICE:
                service = org.ekstep.services.metaService;
                break;
            case ServiceConstants.ASSET_SERVICE:
                service = org.ekstep.services.assetService;
                break;
            case ServiceConstants.TELEMETRY_SERVICE:
                service = org.ekstep.services.telemetryService;
                break;
        }
        return service;
    },

    /**
     * Returns the angular scope object for the plugins that need angular framework to render. The editor
     * uses Angular 2 and plugins must use this to access the scope instead of instantiating Angular by
     * themselves.
     * @memberof org.ekstep.contenteditor.api
     */
    getAngularScope: function() {
        return {};
    },

    /**
     * Returns the HTML5 canvas for rendering on the editor. By default, the editor uses Fabric.js and recommends
     * the plugins to also use Fabric.js for rendering the WYSIWYG components on the editor canvas. However,
     * this method provides access to the underlying native HTML5 canvas if needed. For example, if your plugin
     * uses some other third-party graphics library for rendering.
     * @memberof org.ekstep.contenteditor.api
     */
    getCanvas: function() {
        return org.ekstep.contenteditor.stageManager.canvas;
    },

    /**
     * Retrns the current stage object to the plugin. Plugins might use this to query other objects on the
     * canvas or access other stage context.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentStage: function() {
        //return org.ekstep.contenteditor.stageManager.currentStage;
        return org.ekstep.collectioneditor.collectionService.getActiveNode().data;
    },

    /**
     * Retrns the specified stage to the plugin. This can be used to build scenarios where a plugin might be
     * linking multiple stages together (e.g. when building navigation plugins).
     * @memberof org.ekstep.contenteditor.api
     */
    getStage: function(stageId) {
        return org.ekstep.contenteditor.stageManager.getStage(stageId);
    },

    /**
     * Refreshes the rendering of stages - plugins can request the stages to be refreshed if any change
     * has been made.
     * @memberof org.ekstep.contenteditor.api
     */
    refreshStages: function() {
        /* istanbul ignore next */
        org.ekstep.contenteditor.api.ngSafeApply(org.ekstep.contenteditor.api.getAngularScope(), function() { org.ekstep.contenteditor.toolbarManager.scope.stages = org.ekstep.contenteditor.stageManager.stages; });
    },

    /**
     * Returns the currently selected active object on the canvas. This can be used by plugins to provide
     * contextual support - e.g. show words for a given text object when the text is selected.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentObject: function() {
        var activeObj = org.ekstep.contenteditor.stageManager.canvas.getActiveObject();
        if (!activeObj) return false;
        var pluginId = activeObj.id;
        return org.ekstep.contenteditor.api.getPluginInstance(pluginId);
    },

    /**
     * Returns the current group of selected objects. This is possible when a user does multi-select by
     * clicking on multiple objects or by panning on the canvas.
     * @memberof org.ekstep.contenteditor.api
     */
    getCurrentGroup: function() {
        if(org.ekstep.contenteditor.stageManager.canvas.getActiveGroup()){
        var plugins = org.ekstep.contenteditor.stageManager.canvas.getActiveGroup()._objects;
        var group = [];
        _.forEach(plugins, function(plugins, index) {
            var obj = org.ekstep.contenteditor.api.getPluginInstance(plugins.id);
            group.push(obj);
        });
        return group;
        }
    },

    /**
     * Retrns the current group on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentGroup() instead.
     * @memberof org.ekstep.contenteditor.api
     */
    getEditorGroup: function() {
        var group = org.ekstep.contenteditor.stageManager.canvas.getActiveGroup();
        return group;
    },

    /**
     * Retrns the current object on the fabric canvas. This provides access to the fabric object. If you
     * want to access the plugin instance that is currently selected, use getCurrentObject() instead.
     * @memberof org.ekstep.contenteditor.api
     */
    getEditorObject: function() {
        return org.ekstep.contenteditor.stageManager.canvas.getActiveObject();
    },

    /**
     * Notifies the framework to render the canvas once again. This can be done by the plugin when
     * its config or state is modified via the config views.
     * @memberof org.ekstep.contenteditor.api
     */
    render: function() {
        org.ekstep.contenteditor.stageManager.canvas.renderAll();
    },

    /**
     * Returns a plugin instance for the given plugin ID. Plugins can use this work with dependencies
     * or build plugins that enhance the behavior of other plugins.
     * @memberof org.ekstep.contenteditor.api
     */
    getPluginInstance: function(pluginId) {
        return org.ekstep.pluginframework.pluginManager.getPluginInstance(pluginId);
    },

    /**
     * Allows the plugins to request an update to the context menu when one or more objects are selected.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {object} Menu item to add - see the manifest for the structre of the menu item
     * @memberof org.ekstep.contenteditor.api
     */
    updateContextMenu: function(menu) {
        org.ekstep.contenteditor.toolbarManager.updateContextMenu([menu]);
    },

    /**
     * Allows the plugins to request an update to the context menu by supplying multiple menu items.
     * This can be used by a plugin to add more actions to the context menu - e.g. when a text is selected,
     * a word parser plugin can add context menu for spell check, or for adding word definition popups.
     * @param menu {array} Array of menu items to add - see the manifest for the structre of the menu item
     * @memberof org.ekstep.contenteditor.api
     */
    updateContextMenus: function(menus) {
        org.ekstep.contenteditor.toolbarManager.updateContextMenu(menus);
    },
    updateSidebarMenu: function(menu) {
        org.ekstep.contenteditor.sidebarManager.updateSidebarMenu(menu);        
    },
    /**
     * Allows the plugins to request loading and instantiating another plugin. This is useful when
     * a plugin depends upon other plugins - e.g. a wordpicker might dependend upon an asset picker.
     * @param id {string} Fully qualified plugin id to load and instantiate
     * @param data {object} Data to be passed during instantiation (initial state)
     * @param parent {object} Parent scope - use this
     * @param override {object} Any function overrides - e.g. you can override the handlers of the plugin
     * @see org.ekstep.composite-text-image-shape plugin for a sample of leveraging this.
     * @memberof org.ekstep.contenteditor.api
     */
    instantiatePlugin: function(id, data, parent, override) {
        return org.ekstep.pluginframework.pluginManager.invoke(id, data, parent, override);
    },

    /**
     * Plugins can instantiate a stage and add it to the content. This can be done by special plugins that
     * work at a stage level or cause multiple stages to be added based on the configuration.
     * @param stage {object} Stage to add to the content
     * @memberof org.ekstep.contenteditor.api
     */
    addStage: function(stage) {
        org.ekstep.contenteditor.stageManager.addStage(stage);
    },

    /**
     * Lookup for another plugin in the current plugin manager scope.
     * @param id {string} Plugin id to return. Undefined if the plugin has not been loaded.
     * @memberof org.ekstep.contenteditor.api
     */
    getPlugin: function(id) {
        return org.ekstep.pluginframework.pluginManager.plugins[id];
    },

    /**
     * Adds a plugin instance to the manager. This may be used when a plugin instantiates other plugins. The
     * newly instantiated plugins are added to the framework's registry, making them discoverable by others.
     * Useful for scenarios where plugins depend on others, or composite plugins.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    addPluginInstance: function(pluginInstance) {
        org.ekstep.pluginframework.pluginManager.addPluginInstance(pluginInstance);
    },

    /**
     * Removes a plugin instance from the manager. Do this only if you instantiated the plugin using addPluginInstance()
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    removePluginInstance: function(pluginInstance) {
        org.ekstep.pluginframework.pluginManager.removePluginInstance(pluginInstance);
    },

    /**
     * Creates a deep copy of the given plugin object with an offset x and y position. This is useful when
     * you are building plugins that enable copy paste type functionality for example.
     * @param pluginInstance {object} Plugin object instantiated by this plugin.
     * @memberof org.ekstep.contenteditor.api
     */
    cloneInstance: function(plugin) {
        var data = plugin.getCopy();
        data = _.omit(data, ["id", "event"]);
        if (plugin.parent.id == org.ekstep.contenteditor.api.getCurrentStage().id) {
            data.x = data.x + 2;
            data.y = data.y + 2;
        }
        org.ekstep.contenteditor.api.instantiatePlugin(plugin.manifest.id, data, org.ekstep.contenteditor.api.getCurrentStage());
    },

    /**
     * Returns all stages in the current document. This could be useful when plugins work across stages
     * such as timers that work across stages or page number plugins. Using this, a plugin can get access to all
     * stages, and instantiate plugins on each stage.
     * @memberof org.ekstep.contenteditor.api
     */
    getAllStages: function() {
        return org.ekstep.contenteditor.stageManager.stages;
    },

    /**
     * Selector for plugins of a given type in the document. This can be used by plugins to discover other
     * instances of the same plugin, or other plugins that are compatible with this plugin. E.g. a wordnet
     * plugin might use this to discover all other text plugins in the content.
     * 
     * @param  {String} stage        Stage ID
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof org.ekstep.contenteditor.api
     */
    getStagePluginInstances: function(stage, includeTypes, excludeTypes, excludeIds) {
        // TODO: Add logic to check if stage exists
        var instances = _.clone(org.ekstep.contenteditor.api.getStage(stage).children);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Get matching plugin instances. This function returns instances across all stages matching the given criteria
     * 
     * @param  {Array} includeTypes Include plugins
     * @param  {Array} excludeTypes Exclude plugins
     * @param  {Array} excludeIds   Exclude specific plugin instances
     * @return {Array}              Array of plugin instances matching the given criteria
     * @memberof org.ekstep.contenteditor.api
     */
    getPluginInstances: function(includeTypes, excludeTypes, excludeIds) {
        var instances = _.clone(org.ekstep.pluginframework.pluginManager.pluginInstances);
        if (includeTypes) {
            instances = _.filter(instances, function(obj) {
                return includeTypes.indexOf(obj.manifest.id) != -1;
            });
        }
        if (excludeTypes) {
            instances = _.filter(instances, function(obj) {
                return excludeTypes.indexOf(obj.manifest.id) == -1;
            });
        }
        if (excludeIds) {
            instances = _.filter(instances, function(obj) {
                return excludeIds.indexOf(obj.id) == -1;
            });
        }
        return instances;
    },

    /**
     * Allows plugins to load a media object that they may depend upon.
     * @param assetId {string} ID of the media asset to load
     * @memberof org.ekstep.contenteditor.api
     */
    getMedia: function(assetId) {
        return org.ekstep.contenteditor.mediaManager.getMedia(assetId);
    },

    /**
     * Get the media asset's reverse proxy URL
     * @param  {String} url Fully qualified URL
     * @return {String}     Reverse proxied URL
     * @memberof org.ekstep.contenteditor.api
     */
    getMediaReverseProxyURL: function(url) {
        return org.ekstep.contenteditor.mediaManager.getMediaOriginURL(url);
    },

    /**
     * API to load a plugin dynamically. Any plugin to be loaded should be ideally declared as dependency in the manifest.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @memberof org.ekstep.contenteditor.api
     */
    loadPlugin: function(pluginId, pluginVersion, callback) {
        org.ekstep.pluginframework.pluginManager.loadPluginWithDependencies(pluginId, pluginVersion, "plugin", undefined, [], callback);
    },

    /**
     * Utility API to update the plugin dimenstions once any action like - move, resize etc are performed
     * 
     * @param  {Object} inst Plugin Instance
     * @memberof org.ekstep.contenteditor.api
     */
    updatePluginDimensions: function(inst) {
        inst.attributes.x = inst.editorObj.getLeft();
        inst.attributes.y = inst.editorObj.getTop();
        inst.attributes.w = inst.editorObj.getWidth() - inst.editorObj.getStrokeWidth();
        inst.attributes.h = inst.editorObj.getHeight() - inst.editorObj.getStrokeWidth();
        inst.attributes.rotate = inst.editorObj.getAngle();
        if (_.isFunction(inst.editorObj.getRx))
            inst.attributes.r = inst.editorObj.getRx();
    },
    ngSafeApply: function(scope, fn) {
        if (scope) scope.$safeApply(fn);
    },
    /**
     * API to load and initialize a plugin to the current stage
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {Long} publishedTime   Plugin published timestamp (for cache busting)
     * @param {Class} parent          Parent for the plugin
     * @memberof org.ekstep.contenteditor.api
     */
    loadAndInitPlugin: function(pluginId, pluginVersion, publishedTime, parent) {
        parent = parent || this.getCurrentStage();
        org.ekstep.pluginframework.pluginManager.loadAndInitPlugin(pluginId, pluginVersion, publishedTime, parent);
    },

    /**
     * API to Resolve plugin resource URL. This API would resolve to the repo the plugin is loaded from.
     * 
     * @param  {String} pluginId      Plugin ID
     * @param  {String} pluginVersion Plugin Version
     * @param  {String} resource resource relative URL
     * @return {String}          Resolved URL
     * @memberof org.ekstep.contenteditor.api
     */
    resolvePluginResource: function (id, ver, resource) {
         return org.ekstep.pluginframework.pluginManager.resolvePluginResource(id, ver, resource);
    },

    /**
     * API to register for a keyboard command
     * 
     * @param  {String}   command  Key combination. For ex: ctrl+s, ctrl+c etc
     * @param  {Function} callback Callback to invoke when the key is pressed
     * @memberof org.ekstep.contenteditor.api
     */
    registerKeyboardCommand: function(command, callback) {
        org.ekstep.pluginframework.keyboardManager.registerKeyCombination(command, callback);
    },
    addResourceRepository: function(repo, position) {
        if (repo) org.ekstep.pluginframework.resourceManager.addRepo(repo, position);
    },
    showSidebarMenu: function(sidebarMenuId) {
        org.ekstep.contenteditor.sidebarManager.showSidebarMenu(sidebarMenuId)
    },
    getCurrentSidebarMenu: function() {
        return org.ekstep.contenteditor.sidebarManager.getCurrentMenu();
    }     
}

window.ecEditor = window.org.ekstep.contenteditor.api;
org.ekstep.collectioneditor.api = {
    initEditor: function(config, cb) {
        var startTime = Date.now();
        if (config) org.ekstep.collectioneditor.collectionService.initialize(config);
        org.ekstep.pluginframework.pluginManager.loadAllPlugins(org.ekstep.collectioneditor.config.plugins, undefined, function () {
            org.ekstep.services.telemetryService.initialize({
                uid: config.context.uid,
                sid: config.context.sid,
                content_id: config.context.contentId,
                etags: config.context.etags || {},
                channel:config.context.channel || "",
                pdata: config.context.pdata || {}
            }, org.ekstep.collectioneditor.config.dispatcher);
            org.ekstep.services.telemetryService.startEvent(true).append("loadtimes", { plugins: (Date.now() - startTime) });        
            if (cb) cb();    
        });        
    },
    getService: function(service) {
    	switch (service) {
    		case "collection":
    			return org.ekstep.collectioneditor.collectionService
    			break;
    	}
    },
    registerMetaPage: function(config) {
        if(config) org.ekstep.collectioneditor.metaPageManager.register(config);
    }
}
/**
 * The base plugin class that all editor plugins inherit from. It provides the common support contract for all plugins.
 * Plugins can override specific methods to change the behavior. The most common scenario would be to override the
 * implementation of fabric callback methods to detect interactivity on the canvas.
 *
 * @class org.ekstep.contenteditor.basePlugin
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.contenteditor.basePlugin = Class.extend({
    id: undefined,
    parent: undefined,
    children: [],
    manifest: undefined,
    editorObj: undefined,
    editorData: undefined,
    data: undefined,
    attributes: { x: 0, y: 0, w: 0, h: 0, visible: true, editable: true },
    config: undefined,
    event: undefined,
    events: undefined,
    params: undefined,
    media: undefined,
    configManifest: undefined,

    /**
     * Initializes the plugin with the given manifest and parent object
     * @param manifest {object} Manifest details for this plugin
     * @param data {object} Init parameters for the plugin
     * @param parent {object} Parent plugin object that instantiated this
     * @constructor
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    init: function(manifest, data, parent) {
        var instance = this;
        this.manifest = _.cloneDeep(manifest);
        if (arguments.length == 1) {
            this.registerMenu();
            this.initialize();
            org.ekstep.contenteditor.api.addEventListener(this.manifest.id + ":create", this.create, this);
            console.log(manifest.id + " plugin initialized");
        } else {
            this.editorObj = undefined, this.event = undefined, this.attributes = { x: 0, y: 0, w: 0, h: 0, visible: true }, this.params = undefined, this.data = undefined, this.media = undefined;
            this.editorData = data || {};
            this.children = [];
            this.id = this.editorData.id || UUID();
            this.parent = parent;
            this.config = { opacity: 100, strokeWidth: 1, stroke: "rgba(255, 255, 255, 0)", autoplay: false, visible: true };
        }
        this.configManifest = _.clone(org.ekstep.contenteditor.baseConfigManifest, true);
    },

    /**
     * Initializes the plugin by reading from ECML.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    initPlugin: function() {
        this.fromECML(this.editorData);
        this.newInstance();
        this.postInit();
    },

    /**
     * Post init tasks for the plugin
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    postInit: function() {
        this.registerFabricEvents();
        if (this.editorObj) { this.editorObj.set({ id: this.id }); this.editorObj.setVisible(true); }
        if(_.has(this.manifest.editor, 'behaviour')) {
            if(!_.isUndefined(this.manifest.editor.behaviour.rotatable) && (this.manifest.editor.behaviour.rotatable === true)) {
                if (this.editorObj) { this.editorObj.hasRotatingPoint = true; }
            }
        }
        if (this.parent) this.parent.addChild(this);
        if (this.parent && this.parent.type !== 'stage') org.ekstep.contenteditor.api.dispatchEvent('object:modified', { id: this.id });
    },

    /**
     * Registers the menu for this plugin. By default, the base plugin handles the menu additions.
     * Child implementations can use this method to override and register additional menu items.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    registerMenu: function() {
        var instance = this;
        _.forEach(instance.manifest.editor.header, function(header) {
            org.ekstep.contenteditor.headerManager.register(header, instance.manifest);
        });

        _.forEach(instance.manifest.editor.container, function(container) {
            org.ekstep.contenteditor.containerManager.register(container, instance.manifest);
        });
    },

    /**
     * Returns relative URL for a particular asset. Plugins should use this method instead of
     * hard-coding the asset URLs.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    relativeURL: function(src) {
        return org.ekstep.contenteditor.api.resolvePluginResource(this.manifest.id, this.manifest.ver, src);
    },

    /**
     * Returns the type of this plugin (manifest ID)
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getType: function() {
        return this.manifest.id;
    },

    /**
     * Returns the version of this plugin (manifest ID)
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getVersion: function() {
        return this.manifest.ver;
    },

    /**
     * Registers listeners for Fabricjs events from the canvas. Child implementations should override
     * the actual callback methods instead of overriding this one.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    registerFabricEvents: function() {
        if (this.editorObj) {
            this.editorObj.on({
                added: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.added(inst, options, event);
                    if (inst.editorObj) {
                        org.ekstep.contenteditor.api.updatePluginDimensions(inst);
                    }
                },
                removed: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.removed(inst, options, event);
                    _.forEach(inst.children, function(child, index) {
                        child.editorObj.remove();
                    });
                    inst.remove();
                },
                selected: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.selected(inst, options, event)
                },
                deselected: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.deselected(inst, options, event)
                },
                modified: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    /* istanbul ignore else. This cannot be reached */
                    if (inst.editorObj) {
                        org.ekstep.contenteditor.api.updatePluginDimensions(inst);
                    }
                    inst.changed(inst, options, event)
                },
                rotating: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.rotating(inst, options, event)
                },
                scaling: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.scaling(inst, options, event);
                },
                moving: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.moving(inst, options, event)
                },
                skewing: function(options, event) {
                    var inst = org.ekstep.contenteditor.api.getPluginInstance(this.id);
                    inst.skewing(inst, options, event)
                }
            });
        }
    },

    /**
     * Helper method to load a given resource relative to the plugin.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    loadResource: function(src, dataType, cb) {
        org.ekstep.contenteditor.api.loadPluginResource(this.manifest.id, this.manifest.ver, src, dataType, cb);
    },

    /**
     * Removes the plugin from the stage. This can be used to perform self cleanup. If this method is called
     * from newInstance(), plugin won't be added to stage children.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    remove: function() {
        if (this.parent) {
            this.parent.removeChild(this);
            this.parent =  undefined; // if this method is called from newInstance(), plugin won't be added to stage children    
        }
        delete org.ekstep.pluginframework.pluginManager.pluginInstances[this.id];
    },

    /**
     * Creates the instance of the plugin when a new object is added to the canvas.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    create: function(event, data) {
        org.ekstep.contenteditor.api.instantiatePlugin(this.manifest.id, _.clone(data), org.ekstep.contenteditor.stageManager.currentStage);
    },

    /**
     * Adds a child to this object. This can be useful for composite scenarios.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addChild: function(plugin) {
        this.children.push(plugin);
    },

    /**
     * Removes a child from this plugin. Use this to dynamically manage composite children.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    removeChild: function(plugin) {
        this.children = _.reject(this.children, { id: plugin.id });
    },

    /**
     * Initialize the plugin when it is loaded. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */initialize: function(data) {},

    /**
     * Instantiate an object of the plugin type. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */newInstance: function(data) {},

    /**
     * Called when the plugin is added to the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    added: function(instance, options, event) {},

    /**
     * Called when the plugin is removed from the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    removed: function(instance, options, event) {},

    /**
     * Called when the object is selected on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    selected: function(instance, options, event) {},

    /**
     * Called when the object loses focus on the canvas. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    deselected: function(instance, options, event) {},

    /**
     * Called when the object is modified (dragged, resized or rotated). This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    changed: function(instance, options, event) {},

    /**
     * Called continuously while the object is rotating. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    rotating: function(instance, options, event) {},

    /**
     * Called continuously while the object is scaling. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    scaling: function(instance, options, event) {},

    /**
     * Called continuously while the object is being dragged. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    moving: function(instance, options, event) {},

    /**
     * Called continuously while the object is being skewed. This is a no-op implementation and child classes must
     * provide the complete functional implementation.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    skewing: function(instance, options, event) {},

    /**
     * Allows plugins to create a copy of the object. Default implementation just creates a clone. Child
     * classes can override the logic to customize how copy is done.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    doCopy: function() {
        return this.editorObj;
    },

    /**
     * Returns a copy of the object by converting it to ECML markup.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getCopy: function() {
        return this.toECML();
    },

    /**
     * Renders the plugin to canvas. Default implementation adds the editor fabric object to canvas.
     * Complex plugins and templates should override this if necessary.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    render: function(canvas) {
        canvas.add(this.editorObj);
    },

    /**
     * Returns the metadata of the object. This is a no-op implementation. Child plugins should override
     * this method to return custom metadata.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */
    getMeta: function() {},

    /**
     * Utility method to convert canvas pixels to relative units. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    pixelToPercent: function(obj) {
        obj.x = parseFloat(((obj.x / 720) * 100).toFixed(2));
        obj.y = parseFloat(((obj.y / 405) * 100).toFixed(2));
        obj.w = parseFloat(((obj.w / 720) * 100).toFixed(2));
        obj.h = parseFloat(((obj.h / 405) * 100).toFixed(2));
        obj.rotate = parseFloat(obj.rotate);
    },

    /**
     * Utility method to convert relative units to pixels on canvas. By design, all rendering must work with
     * relative units to allow content to be rendered on different types of devices with different pixel
     * ratios and density. Plugins must always use the relative units for rendering.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    percentToPixel: function(obj) {
        obj.x = obj.x * (720 / 100);
        obj.y = obj.y * (405 / 100);
        obj.w = obj.w * (720 / 100);
        obj.h = obj.h * (405 / 100);
        obj.rotate = obj.rotate;
    },

    /**
     * Sets the config for this object. Override this method to parse the config if necessary.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setConfig: function(data) {
        this.config = data;
    },

    /**
     * Adds a given config key and value pair to the config for this plugin instance.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addConfig: function(key, value) {
        if (_.isUndefined(this.config)) this.config = {};
        this.config[key] = value;
    },

    /**
     * Returns the config for this plugin. Child plugins should override this method to generate the
     * custom plugin JSON objects.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getConfig: function() {
        return this.config;
    },

    /**
     * Returns the data that this plugin might set and use at runtime. As a best practice, plugins should
     * differentiate between config (e.g. rendering colors, font size, levels etc) and data (actual
     * word details to use).
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setData: function(data) {
        this.data = data;
    },

    /**
     * Returns the data for this plugin. Data includes actual drivers - such as the words in a word game
     * or questions in a quiz. Plugins should set their data is they want to differentiate from
     * the config.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getData: function() {
        return this.data;
    },

    /**
     * Manages the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setAttributes: function(attr) {
        _.merge(this.attributes, attr);
    },

    /**
     * Returns the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getAttributes: function() {
        return _.omit(this.attributes, ['top', 'left', 'width', 'height']);
    },

    /**
     * Modigies the ECML attributes for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    setAttribute: function(key, value) {
        this.attributes[key] = value;
    },

    /**
     * Returns the individual ECML attribute for the plugins. This includes x,y,w,h and rotation related attributes
     * that are common to all plugins.
     * @param key {string} Attribute name
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getAttribute: function(key) {
        return this.attributes[key];
    },

    /**
     * Adds a runtime event listener for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addEvent: function(event) {
        if (_.isUndefined(this.event)) this.event = [];
        this.event.push(event);
    },

    /**
     * Returns the list of runtime events configured for this plugin. Plugins can respond to events on the renderer
     * such as stage entry, exit or results of evaluation.
     * @param event {object} Event object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getEvents: function() {
        return this.event;
    },

    /**
     * Adds a runtime param - such as teacher instructions to the ECML output. Params are like shared variables
     * that can be used for evaluation across stages on the renderer.
     * @param key {string} Name of the runtime parameter
     * @param value {object} Data of the parameter
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addParam: function(key, value) {
        if (_.isUndefined(this.params)) this.params = {};
        this.params[key] = value;
    },

    /**
     * Removes a runtime param for this plugin.
     * @param key {string} Name of the param to remove.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    deleteParam: function(key){
        if(this.params) delete this.params[key];
    },

    /**
     * Returns the list of runtime params for this plugin.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getParams: function() {
        return this.params;
    },

    /**
     * Returns the specified runtime parameter details. Note that the value of the parameter
     * is only available at runtime.
     * @param key {string} Name of the param to return.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getParam: function(key) {
        return this.params ? this.params[key] : undefined;
    },

    /**
     * Adds media to the manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    addMedia: function(media) {
        if (_.isUndefined(this.media)) this.media = {};
        this.media[media.id] = media;
    },

    /**
     * Returns the media manifest of this plugin. You can add media such as images, audios, or even
     * other runtime dependencies such as JS, CSS and other plugin files. If you don't declare a
     * media, it will not be included in the content download archive.
     * @param media {object} Media to be included at runtime.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getMedia: function() {
        return this.media;
    },

    /**
     * Returns the renderer dimensions for this plugin. This includes the x,y,w,h bounding box,
     * and the rotation of the object.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getRendererDimensions: function() {
        var attr = this.getAttributes();
        var dims = {
            x: attr.x,
            y: attr.y,
            w: attr.w,
            h: attr.h,
            rotate: attr.rotate
        }
        this.pixelToPercent(dims);
        return dims;
    },

    /**
     * Generates and returns the ECML string for this plugin.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    toECML: function() {
        if(this.editorObj) org.ekstep.contenteditor.api.updatePluginDimensions(this);
        var attr = _.clone(this.getAttributes());
        attr.id = this.id;
        this.pixelToPercent(attr);
        if (!_.isUndefined(this.getData())) {
            attr.data = {
                "__cdata": JSON.stringify(this.getData())
            };
        }
        if (!_.isUndefined(this.getConfig())) {
            attr.config = {
                "__cdata": JSON.stringify(this.getConfig())
            };
        }
        if (!_.isUndefined(this.getEvents())) {
            // attr.config = {
            //     "__cdata": JSON.stringify(this.getEvents())
            // };
            attr.event = this.getEvents();
        }
        if (!_.isUndefined(this.getParams())) {
            attr.param = [];
            _.forIn(this.getParams(), function(value, key) {
                attr.param.push({ name: key, value: value });
            });
        }
        return attr;
    },

    /**
     * Parses the ECML to construct this object.
     * @private
     * @param data {object} ECML to recontruct from
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    fromECML: function(data) {
        var instance = this;
        this.attributes = data;
        if (!_.isUndefined(this.attributes.data)) {
            this.data = this.attributes.data.__cdata ? JSON.parse(this.attributes.data.__cdata) : this.attributes.data;
            delete this.attributes.data;
        }
        if (!_.isUndefined(this.attributes.config)) {
            this.config = this.attributes.config.__cdata ? JSON.parse(this.attributes.config.__cdata) : this.attributes.config;
            delete this.attributes.config;
        }
        if (!_.isUndefined(this.attributes.events)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            delete this.attributes.events;
        }
        if (!_.isUndefined(this.attributes.event)) {
            //this.events = JSON.parse(this.attributes.event.__cdata);
            this.event = this.attributes.event;
            delete this.attributes.event;
        }
        if (!_.isUndefined(this.attributes.param)) {
            _.forEach(this.attributes.param, function(param) {
                instance.addParam(param.name, param.value);
            })
            delete this.attributes.param;
        }
        if (!_.isUndefined(this.attributes.asset)) {
            if (!_.isUndefined(this.attributes.assetMedia)) {
                instance.addMedia(this.attributes.assetMedia);
                delete this.attributes.assetMedia;
            } else {
                var media = org.ekstep.contenteditor.mediaManager.getMedia(this.attributes.asset);
                if (!_.isUndefined(media)) {
                    instance.addMedia(media);
                }
            }
        }
        this.percentToPixel(this.attributes);
    },

    /**
     * Utility function to conver the data of the object to Fabric properties - a simple variable
     * transformation that returns the corresponding fabric parameter names.
     * @param data {object} Data of the current plugin instance.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    convertToFabric: function(data) {
        var retData = _.clone(data);
        if (data.x) retData.left = data.x;
        if (data.y) retData.top = data.y;
        if (data.w) retData.width = data.w;
        if (data.h) retData.height = data.h;
        if (data.radius) retData.rx = data.radius;
        if (data.color) retData.fill = data.color;
        if (data.rotate) retData.angle = data.rotate;
        return retData;
    },
    getConfigManifest: function() {
        if (!this.manifest.editor.configManifest) { this.manifest.editor.configManifest = []; }
        var configManifest = this.manifest.editor.configManifest
        if (this.configManifest) {
            configManifest = _.uniqBy(_.clone(_.concat(this.manifest.editor.configManifest, this.configManifest),true),'propertyName');
        }
        if (!(this.manifest.editor.playable && this.manifest.editor.playable === true)) {
          _.remove(configManifest, function (cm) {return cm.propertyName === 'autoplay'})
        }
        return configManifest
    },

    /**
     * Allows a plugin to update the context menu when the plugin instance is selected. Plugins can use
     * this method to change any specific custom context menu actions.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next */
    updateContextMenu: function() {},

    /**
     * Plugins can override this to reset their configuration.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */
    reConfig: function() {},

    onConfigChange: function() {},

    /**
     * Called when the configuration is modified for the plugin. This is useful if the plugin
     * has to provide WYSIWYG feedback on the fabric canvas.
     * @param key {string} Config property name
     * @param value {string} Value of the config setting.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    _onConfigChange: function(key, value) {
        this.addConfig(key, value);
        var currentInstace = org.ekstep.contenteditor.api.getCurrentObject();
        if (currentInstace) {
            if (currentInstace.config === undefined) { currentInstace.config = {} }
            switch (key) {
                case 'opacity':
                    currentInstace.editorObj.setOpacity(value/100);
                    currentInstace.attributes.opacity = value/100;
                    currentInstace.config.opacity = value;
                    break;
                case 'strokeWidth':
                    value = parseInt(value);
                    currentInstace.editorObj.set('strokeWidth', value);
                    currentInstace.attributes['stroke-width'] = value;
                    currentInstace.attributes['strokeWidth'] = value;
                    currentInstace.config.strokeWidth = value;
                    break;
                case 'stroke':
                    currentInstace.editorObj.setStroke(value);
                    currentInstace.attributes.stroke = value;
                    currentInstace.config.stroke = value;
                    break;
                case 'autoplay':
                    currentInstace.attributes.autoplay = value;
                    currentInstace.config.autoplay = value;
                    break;
                case 'visible':
                    currentInstace.attributes.visible = value;
                    currentInstace.config.visible = value;
                    break;
            }
            org.ekstep.contenteditor.api.render();
            org.ekstep.contenteditor.api.dispatchEvent('object:modified', { target: org.ekstep.contenteditor.api.getEditorObject() });
        }
    },

    /**
     * Returns the help text for this plugin by reading the help markdown file. Plugins can override this
     * to return custom help.
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    /* istanbul ignore next. test case failing */
    getHelp: function(cb) {        
        var helpText = "Help is not available."
        try {
            this.loadResource(this.manifest.editor.help.src, this.manifest.editor.help.dataType, function(err, help) {
                if (!err) {
                    helpText = help;
                    cb(helpText);
                }
            });
        } catch (e) {
            console.log(e)
            cb(helpText);
        }
    },

    /**
     * Returns the properties that editable for this plugin instance.
     * @private
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getProperties: function() {
        var props = _.omitBy(_.clone(this.attributes), _.isObject);
        props = _.omitBy(props, _.isNaN);
        this.pixelToPercent(props);
        return props;
    },

    /**
     * Renders the configuration view for this plugin. Default functionality is to launch the config
     * property editor. Plugins can override this method to change the way config is rendered.
     * @memberof org.ekstep.contenteditor.basePlugin
     */    
    /* istanbul ignore next */renderConfig: function() {},

    /**
     * Returns the manifest ID of this object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getManifestId: function () {
      return (this.manifest.shortId || this.manifest.id);
    },

    /**
     * Returns the displayName of this object
     * @memberof org.ekstep.contenteditor.basePlugin
     */
    getDisplayName: function () {
         return (this.manifest.displayName || this.manifest.id);
    }
});

org.ekstep.contenteditor.headerManager = new(Class.extend({
	registeredHeaders: [],
	initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    register: function(header, manifest) {
    	this.registeredHeaders.push({ id: manifest.id, header: header });
    	this.load(header, manifest);
    },
    load: function(header, manifest) {
        var instance = this;        
        if (header.templateURL) {
            header.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, header.templateURL);
            instance.loadNgModules(header.templateURL);

            if (header.controllerURL) {
                header.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, header.controllerURL);
                instance.loadNgModules(undefined, header.controllerURL)
                    .then(function() {
                        instance.scope.addToHeader(header);
                    }, function() {
                        throw "unable to load controller :" + header.controllerURL;
                    });
            } else {
                instance.scope.addToHeader(header);
            }
        };
    }   
}));
org.ekstep.contenteditor.containerManager = new(Class.extend({
	registeredContainer: [],
	initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
        this.scope = config.scope
    },
    register: function(container, manifest) {
    	this.registeredContainer.push({ id: manifest.id, container: container });
    	this.load(container, manifest);
    },
    load: function(container, manifest) {
        var instance = this;        
        if (container.templateURL) {
            container.templateURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, container.templateURL);
            instance.loadNgModules(container.templateURL);

            if (container.controllerURL) {
                container.controllerURL = org.ekstep.contenteditor.api.resolvePluginResource(manifest.id, manifest.ver, container.controllerURL);
                instance.loadNgModules(undefined, container.controllerURL)
                    .then(function() {
                        instance.scope.addToContainer(container);
                    }, function() {
                        throw "unable to load controller :" + container.controllerURL;
                    });
            } else {
                instance.scope.addToContainer(container);
            }
        };
    }   
}));
org.ekstep.collectioneditor.metaPageManager = new(Class.extend({
    registeredPages: [],
    initialize: function(config) {
        this.loadNgModules = config.loadNgModules;
    },
    register: function(config) {
        var instance = this;
        if (config.templateURL) {
            instance.loadNgModules(config.templateURL);
            if (config.controllerURL) {
                instance.loadNgModules(undefined, config.controllerURL)
                    .then(function() {
                        instance.registeredPages.push(config);
                    }, function() {
                        throw "unable to load controller :" + config.controllerURL;
                    });
            }
        };
    },
    getPages: function() {
        return this.registeredPages;
    }
}));

org.ekstep.collectioneditor.collectionService = new(Class.extend({
    config: undefined,
    data: {},
    initialize: function(config) {
        if (config) this.config = config;
    },
    getConfig: function() {
        return this.config;
    },
    getTreeObject: function() {
        return ecEditor.jQuery("#collection-tree").fancytree("getTree").toDict(true);
    },
    getActiveNode: function() {
        return ecEditor.jQuery("#collection-tree").fancytree("getTree").getActiveNode();
    },
    setNodeTitle: function(title) {
        var instance = this;
        if (title) ecEditor.jQuery("#collection-tree").fancytree("getTree").getActiveNode().applyPatch({ 'title': title }).done(function(a, b) {
            instance.onRenderNode(undefined, { node: ecEditor.jQuery("#collection-tree").fancytree("getTree").getActiveNode() }, true);
        });
    },
    setActiveNode: function(key) {
        if (key) ecEditor.jQuery("#collection-tree").fancytree("getTree").getNodeByKey(key).setActive();
    },
    clearFilter: function() {
        ecEditor.jQuery("#collection-tree").fancytree("getTree").clearFilter();
    },
    filterNode: function(text) {
        if (text) ecEditor.jQuery("#collection-tree").fancytree("getTree").filterNodes(text, { autoExpand: true });
    },
    addNode: function(objectType, data) {
        data = data || {};
        var selectedNode = this.getActiveNode();
        objectType = this.getObjectType(objectType);
        var node = {};
        node.title = data.name ? data.name : 'Untitled ' + objectType.label;
        node.objectType = data.contentType || objectType.type;
        node.id = data.identifier ? data.identifier : UUID();
        node.root = false;
        node.folder = (objectType.childrenTypes.length > 0);
        node.icon = objectType.iconClass;
        node.metadata = data || {};
        if (node.folder) { selectedNode.addChildren(node).setActive(); } else { selectedNode.addChildren(node) };
        selectedNode.sortChildren(null, true);
        selectedNode.setExpanded();
        org.ekstep.services.telemetryService.interact({ "type": 'click', "subtype": 'add', "target": 'node', "pluginid": "org.ekstep.collectioneditor", "pluginver": "1.0", "objectid": node.id, "stage": node.id });
    },
    removeNode: function() {
        var selectedNode = this.getActiveNode();
        if (!selectedNode.data.root) {
            ecEditor.getService('popup').open({
                template: '<div class="ui icon negative message remove-unit-popup"><i class="close icon" ng-click="closeThisDialog()"></i><div class="content"><div class="header"><i class="fa fa-exclamation-triangle"></i> Do you want to remove this?</div><div class="remove-unit-buttons" style="padding-right:0; text-align:right;"><div class="ui red button button-overrides" id="remove-yes-button" ng-click="confirm()">Yes</div><div class="ui basic primary button button-overrides" id="remove-no-button" ng-click="closeThisDialog()">No</div></div></div></div>',
                controller: ["$scope", function($scope) {
                    $scope.confirm = function() {
                        selectedNode.remove();
                        $scope.closeThisDialog();
                        delete org.ekstep.collectioneditor.cache.nodesModified[selectedNode.data.id];
                    };
                }],
                plain: true,
                showClose: false
            });
        }
    },
    getContextMenuTemplate: function(objectType) {
        var instance = this;
        var childrenTypes = this.getObjectType(objectType).childrenTypes;
        var contextMenu = "";
        if (childrenTypes && childrenTypes.length === 0) return undefined;
        ecEditor._.forEach(childrenTypes, function(types) {
            if (instance.getObjectType(types).addType === "Browser") {
                contextMenu = contextMenu + '<div class="item" onclick="org.ekstep.collectioneditor.collectionService.addLesson(\'' + types + '\')"><i class="' + instance.getObjectType(types).iconClass + '"></i>&nbsp;' + instance.getObjectType(types).label + '</div>';
            } else {
                contextMenu = contextMenu + '<div class="item" onclick="org.ekstep.collectioneditor.api.getService(\'collection\').addNode(\'' + types + '\')"><i class="' + instance.getObjectType(types).iconClass + '"></i>&nbsp;' + instance.getObjectType(types).label + '</div>';
            }
        });

        return '<span style="padding-left: 20px;left: 65%;">' +
            '<div class="ui inline dropdown">' +
            '<i class="add square icon"></i>' +
            '<div class="menu">' +
            contextMenu +
            '</div>' +
            '</div>' +
            '<i class="remove icon" onclick="org.ekstep.collectioneditor.api.getService(\'collection\').removeNode()"></i></span>'
    },
    addLesson: function(type) {
        var instance = this;
        ecEditor.dispatchEvent("org.ekstep.lessonbrowser:show", {
            filters: { lessonType: [type] },
            callback: function(err, res) {
                if (res) {
                    _.forEach(res, function(obj) {
                        instance.addNode(obj.contentType, obj);
                    });
                }
            }
        });
    },
    addTree: function(tree) {
        var instance = this;
        ecEditor.jQuery("#collection-tree").fancytree({
            extensions: ["dnd", "filter"],
            source: tree,
            modifyChild: function(event, data) {
                if (data && data.operation === "remove") {
                    org.ekstep.services.telemetryService.interact({ "type": 'click', "subtype": 'remove', "target": 'node', "pluginid": "org.ekstep.collectioneditor", "pluginver": "1.0", "objectid": data.node.data.id, "stage": data.node.data.id });
                    ecEditor.jQuery("#collection-tree").fancytree("getRootNode").getFirstChild().setActive();
                }
            },
            activate: function(event, data) {
                ecEditor.dispatchEvent('org.ekstep.collectioneditor:node:selected', data.node);
                ecEditor.dispatchEvent('org.ekstep.collectioneditor:node:selected:' + data.node.data.objectType, data.node);
                org.ekstep.services.telemetryService.interact({ "type": 'click', "subtype": 'select', "target": 'node', "pluginid": "org.ekstep.collectioneditor", "pluginver": "1.0", "objectid": data.node.data.id, "stage": data.node.data.id });
            },
            dnd: {
                autoExpandMS: 400,
                focusOnClick: true,
                preventVoidMoves: true, // Prevent dropping nodes 'before self', etc.
                preventRecursiveMoves: true, // Prevent dropping nodes on own descendants
                dragStart: function(node, data) {
                    var config = instance.getConfig();
                    if (config.mode === "Edit") return true;
                    if (config.mode === "Read") return false;
                },
                dragEnter: function(node, data) {
                    return true;
                },
                dragDrop: function(node, data) {
                    if (data.hitMode === "before" || data.hitMode === "after") return false;
                    if (instance.config.rules && instance.config.rules.levels) {
                        if ((instance.maxTreeDepth(data.otherNode) + node.getLevel()) > instance.config.rules.levels) {
                            ecEditor.dispatchEvent("org.ekstep.toaster:warning", {
                                title: 'This operation is not allowed!',
                                position: 'topCenter',
                                icon: 'fa fa-warning'
                            });
                            return false;
                        }
                    }
                    if (node.data && node.data.objectType) {
                        var dropAllowed = _.includes(instance.getObjectType(node.data.objectType).childrenTypes, data.otherNode.data.objectType);
                        if (dropAllowed) {
                            data.otherNode.moveTo(node, data.hitMode);
                            org.ekstep.services.telemetryService.interact({ "type": 'click', "subtype": 'dragndrop', "target": 'node', "pluginid": "org.ekstep.collectioneditor", "pluginver": "1.0", "objectid": data.node.data.id, "stage": data.node.data.id });
                        } else {
                            ecEditor.dispatchEvent("org.ekstep.toaster:warning", {
                                title: "\"" + data.otherNode.title + "\"" + " cannot be added to " + "\"" + data.node.title + "\"",
                                position: 'topCenter',
                                icon: 'fa fa-warning'
                            });                            
                        }
                    }
                },
                filter: {
                    autoApply: true,
                    autoExpand: false,
                    counter: true,
                    fuzzy: false,
                    hideExpandedCounter: true,
                    hideExpanders: false,
                    highlight: true,
                    leavesOnly: false,
                    nodata: true,
                    mode: "dimm"
                }
            },
            renderNode: function(event, data) {
                instance.onRenderNode(event, data)
            }
        });
        var node = ecEditor.jQuery("#collection-tree").fancytree("getRootNode");
        node.sortChildren(null, true);
        node.getFirstChild().setActive(); //select the first node by default
    },
    onRenderNode: function(event, data, force) {
        var instance = this;
        var node = data.node;
        var $nodeSpan = $(node.span);
        var config = this.config;
        // for read mode do not add context menu on node
        if (config.mode === "Read") return;
        // limit adding nodes depending on config levels for nested stucture
        if (((!$nodeSpan.data('rendered') || force) && data.node.getLevel() >= config.rules.levels) || (!$nodeSpan.data('rendered') && this.getObjectType(data.node.data.objectType).childrenTypes.length == 0)) {
            var contextButton = $('<span style="padding-left: 20px;left: 65%;"><i class="remove icon" onclick="org.ekstep.collectioneditor.api.getService(\'collection\').removeNode()"></i></span>');
            $nodeSpan.append(contextButton);
            contextButton.hide();
            $nodeSpan.hover(function() { contextButton.show(); }, function() { contextButton.hide(); });
            $nodeSpan.data('rendered', true);
        }

        if ((!$nodeSpan.data('rendered') || force) && (this.getObjectType(data.node.data.objectType).childrenTypes.length > 0)) {
            if (org.ekstep.collectioneditor.collectionService.getContextMenuTemplate(data.node.data.objectType)) {
                var contextButton = $(org.ekstep.collectioneditor.collectionService.getContextMenuTemplate(data.node.data.objectType));
                $nodeSpan.append(contextButton);
                $nodeSpan.hover(function() { contextButton.show(); }, function() { contextButton.hide(); });
                $nodeSpan.data('rendered', true);
                contextButton.hide();
                instance.initContextMenuDropDown();
            }
        }
    },
    initContextMenuDropDown: function() {
        setTimeout(function() {
            ecEditor.jQuery('.ui.inline.dropdown').dropdown({ on: 'hover' });
        }, 200);
    },
    getObjectType: function(type) {
        return _.find(this.config.rules.objectTypes, function(obj) {
            return obj.type === type
        });
    },
    fromCollection: function(data) {
        var treeData = this._buildTree(data);
        var instance = this;
        this.addTree([{
            "id": data.identifier || UUID(),
            "title": data.name,
            "objectType": data.contentType,
            "metadata": _.omit(data, ["children", "collections"]),
            "folder": true,
            "children": treeData,
            "root": true,
            "icon": instance.getObjectType(data.contentType).iconClass
        }]);
    },
    _buildTree: function(data, tree) {
        var instance = this,
            tree = tree || [];
        _.forEach(data.children, function(child) {
            var objectType = instance.getObjectType(child.contentType);
            var childTree = [];
            if (objectType) {
                tree.push({
                    "id": child.identifier || UUID(),
                    "title": child.name,
                    "objectType": child.contentType,
                    "metadata": _.omit(child, ["children", "collections"]),
                    "folder": (objectType.childrenTypes.length > 0),
                    "children": childTree,
                    "root": false,
                    "icon": instance.getObjectType(child.contentType).iconClass
                });
                if (objectType.childrenTypes.length > 0) {
                    instance._buildTree(child, childTree);
                }
            }
        });

        return tree;
    },
    getCollectionHierarchy: function() {
        var instance = this;
        this.data = {};
        var data = ecEditor.jQuery("#collection-tree").fancytree("getRootNode").getFirstChild();
        return {
            nodesModified: org.ekstep.collectioneditor.cache.nodesModified,
            hierarchy: instance._toFlatObj(data)
        };
    },
    _toFlatObj: function(data) {
        var instance = this;
        instance.data[data.data.id] = {
            "name": data.title,
            "contentType": data.data.objectType,
            "children": [],
            "root": data.data.root
        }

        if (data.children && data.children.length > 0) {
            instance.data[data.data.id].children = ecEditor._.map(data.children, function(child) {
                return child.data.id
            });
        }

        ecEditor._.forEach(data.children, function(collection) {
            instance._toFlatObj(collection);
        });

        return instance.data;
    },
    maxTreeDepth: function(root) {
        var buffer = [{ node: root, depth: 1 }];
        var current = buffer.pop();
        var max = 0;

        while (current && current.node) {
            // Find all children of this node.
            _.forEach(current.node.children, function(child) {
                buffer.push({ node: child, depth: current.depth + 1 });
            });
            if (current.depth > max) max = current.depth;
            current = buffer.pop();
        }
        return max;
    }
}));

/**
 *
 * Popup service helps to show interactive popup modal/dialog window from plugin
 *
 * @class org.ekstep.services.popupService
 * @author Sunil A S <sunils@ilimi.in>
 */
org.ekstep.services.popupService = new(org.ekstep.services.iService.extend({
    loadModules: undefined,
    openModal: undefined,
    initService: function(loadModuleFn, openModalFn) {
        this.loadModules = loadModuleFn;
        this.openModal = openModalFn;
    },
    /**
     *
     * loads HTML template and angular module
     * @param templatePath {string} path to HTML template
     * @param controllerPath {string} path to angular module
     * @memberof org.ekstep.services.popupService
     */
    loadNgModules: function(templatePath, controllerPath) {
        return this.loadModules(templatePath, controllerPath)
    },
    /**
     *
     * opens popup modal/dialog window
     * @param config {object} config object refers to ngDialog open method parameter. please refer [ngDialog docs]{@link https://github.com/likeastore/ngDialog#openoptions}
     * @param callback {function} pre close Callback
     * @memberof org.ekstep.services.popupService
     */
    open: function(config, callback) {
        /* istanbul ignore else */
        if (this.openModal) {
            this.openModal(config, callback);
            org.ekstep.services.telemetryService.interact({ "type": "click", "subtype": "open", "target": "popup", "pluginid": "", "pluginver": '', "objectid": "", "stage": ecEditor.getCurrentStage().id });
        }
    }
}));

/**
 *
 * Telemetry service helps to log telemetry events. Telemetry service generates below listed events
 * and logs to registered dispatchers.
 * <ol>
 *  <li>CE_START
 *  <li>CE_API_CALL
 *  <li>CE_INTERACT
 *  <li>CE_PLUGIN_LIFECYCLE
 *  <li>CE_ERROR
 *  <li>CE_END
 * </ol>
 *
 * @class org.ekstep.services.telemetryService
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
org.ekstep.services.telemetryService = new(org.ekstep.services.iService.extend({
    context: {},
    dispatchers: [],
    initialized: true,
    start_event: undefined,
    startEventData: undefined,
    /**
    * 
    * Initialize the service with context and dispatcher.     
    * @param context {object} context object can have uid, sid, context_id. 
    * context should have content id, otherwise telemetry service cannot be initialized.
    * @param dispatcher {string} There are 3 types of dispatcher available, anyone of dispatcher 
    * is allowed and same dispatcher is used throughout the editor session. 
    * <ol>
    *   <li>Local dispatcher - dev environment only, logs to file (telemetry.log) - value: "local"
    *   <li>piwik dispatcher - logs to piwik endpoint - value: "piwik"
    *   <li>console dispatcher - logs to client console, default dispatcher - value: undefined
    * </ol>
    * 
    * @memberof org.ekstep.services.telemetryService
    *
    */
    initialize: function(context, dispatcher) {
        var instance = this;
        this.context = context;
        /* istanbul ignore else */
        if(this.context.cdata == undefined) {
            this.context.cdata = [];
        }
        if((this.context.uid == undefined) || (this.context.sid == undefined) || (this.context.content_id == undefined)) {
            console.error('Unable to instantiate telemetry service');
            this.initialized = false;
        }
        this.addDispatcher(dispatcher);

        window.addEventListener('unload', /* istanbul ignore next */ function() {
            instance.end();
        }); 

        this.startEventData = { defaultPlugins: Object.keys(org.ekstep.pluginframework.pluginManager.plugins), loadtimes: {}, client: {} };
    },
    /**
    *
    * to populate data for start event (CE_START)  
    * @param autoplublish {boolean} if "true" logs the events through dispatcher. 
    * @returns {object} returns method chain. 
    * <ol>
    *   <li> <pre>getData()</pre>: return start event data
    *   <li> <pre>append(param, dataObj)</pre>: appends only "loadtimes" param of CE_START with dataObj(type: object). 
    * <ol> 
    * @memberof org.ekstep.services.telemetryService
    *
    */
    startEvent: function(autopublish) {
        var instance = this;
        return {
            getData: function() {
                return instance.startEventData;
            },
            append: function(param, dataObj) {
                for (var key in dataObj) {
                    instance.startEventData[param][key] = dataObj[key];
                }
                if (autopublish) instance.start();
            }
        }
    },
    /**
    *
    * returns dispatcher instance
    * @param dispatcherId {string}     
    * <ol>
    *   <li>Local dispatcher: value: "local"
    *   <li>piwik dispatcher: value: "piwik"
    *   <li>(default) console dispatcher: value: undefined 
    * </ol>
    * @returns dispatcher {object}
    * @memberof org.ekstep.services.telemetryService
    *
    */
    getDispatcher: function(dispatcherId) {
        switch(dispatcherId) {
            case "local":
                return org.ekstep.contenteditor.localDispatcher;
            case "piwik":
                return org.ekstep.contenteditor.piwikDispatcher;
            default:
                return org.ekstep.contenteditor.consoleDispatcher;
        }
    },
    /**
    * 
    * To add a dispatcher to the dispatcher registry
    * @param dispatcherId {string}
    * <ol>
    *   <li>Local dispatcher: value: "local"
    *   <li>piwik dispatcher: value: "piwik"
    *   <li>(default) console dispatcher: value: undefined 
    * </ol>
    * @memberof org.ekstep.services.telemetryService
    *
    */
    addDispatcher: function(dispatcherId) {
        var dispatcher = this.getDispatcher(dispatcherId);
        var dispatcherExist = this.dispatchers.find(function(obj){
           return  obj.type === dispatcher.type;
        });
        if(!dispatcherExist) this.dispatchers.push(dispatcher);
    },
    /**
     *
     * dispatch event to all registered dipatchers
     * @private
     * @param message {event} structured event
     * @memberof org.ekstep.services.telemetryService
     *
     */
    _dispatch: function(message) {
        if (this.initialized) {
            message.mid = 'CE:' + CryptoJS.MD5(JSON.stringify(message)).toString();
            _.forEach(this.dispatchers, function(dispatcher) {
                dispatcher.dispatch(message);
            });
        }
    },
    /**
    *
    * returns structured telemetry event for the given data
    * @param eventId {string} 
    * <ol>
    *  <li>CE_START
    *  <li>CE_API_CALL
    *  <li>CE_INTERACT
    *  <li>CE_PLUGIN_LIFECYCLE
    *  <li>CE_ERROR
    *  <li>CE_END
    * </ol>
    * @param data {object} telemetry data object specified for each telemetry event.
    * @memberof org.ekstep.services.telemetryService
    *
    */
    getEvent: function(eventId, data) {
        return {
            "eid": eventId,
            "mid": "",
            "ets": (new Date()).getTime(), 
            "channel":this.context.channel,
            "ver": "2.1",
            "pdata":this.context.pdata,
            "cdata": this.context.cdata, //TODO: No correlation data as of now. Needs to be sent by portal in context
            "uid": this.context.uid, // uuid of the requester
            "context": {"sid": this.context.sid,"content_id": this.context.content_id},
            "rid": "", // Leave blank.
            "edata": { "eks": data},
            "etags":this.context.etags            
        }
    },
    /**
    *
    * validates telemetry data with mandatory fields
    * @param data {object} telemetry data
    * @param mandatoryFields {array} required fields for the specific telemetry to validate
    * @memberof org.ekstep.services.telemetryService
    *
    */
    hasRequiredData: function(data, mandatoryFields) {
        var isValid = true;
        mandatoryFields.forEach(function(key) {
            if (!data.hasOwnProperty(key)) isValid = false;
        });
        return isValid;
    },
    interactRequiredFields: ["type", "subtype", "target", "pluginid", "pluginver", "objectid", "stage"],
    lifecycleRequiredFields: ["type", "pluginid", "pluginver", "objectid", "stage"],
    errorRequiredFields: ["env", "stage", "action", "err", "type", "data", "severity", "objectid", "objecttype"],
    apiCallRequiredFields: ["path", "method", "request", "response","responseTime", "status", "uip"],
    /**
    *
    * dispatches interact event (CE_INTERACT)
    * @param data {object} interact event data
    * @memberof org.ekstep.services.telemetryService
    *
    */
    interact: function(data) {
        if(!this.hasRequiredData(data, this.interactRequiredFields)) {
            console.error('Invalid interact data');
            return;
        }
        this._dispatch(this.getEvent('CE_INTERACT', data))
    },
    /**
    *
    * dispatches end event (CE_END)
    * @memberof org.ekstep.services.telemetryService
    *
    */
    end: function() {
        var endEvent = this.getEvent('CE_END', {});
        endEvent.edata.eks.duration = (new Date()).getTime() - this.start_event.ets;
        this._dispatch(endEvent);
    },
    /**
    *
    * dispatches plugin lifecycle event (CE_PLUGIN_LIFECYCLE)
    * @param data {object} plugin lifecycle event data
    * @memberof org.ekstep.services.telemetryService
    *
    */
    pluginLifeCycle: function(data) {
        if(!this.hasRequiredData(data, this.lifecycleRequiredFields)) {
            console.error('Invalid plugin lifecycle event data');
            return;
        }
        this._dispatch(this.getEvent('CE_PLUGIN_LIFECYCLE', data))
    },
    /**
    *
    * dispatches error event (CE_ERROR)
    * @param data {object} error event data
    * @memberof org.ekstep.services.telemetryService
    *
    */
    error: function(data) {
        if(!this.hasRequiredData(data, this.errorRequiredFields)) {
            console.error('Invalid error data');
            return;
        }
        this._dispatch(this.getEvent('CE_ERROR', data))
    },
    /**
    *
    * dispatches start event (CE_START)
    * @memberof org.ekstep.services.telemetryService
    *
    */
    start: function() {
        this.startEventData.client = this.detectClient();
        this.start_event = this.getEvent('CE_START', this.startEventData);
        this._dispatch(this.start_event);
    },
    /**
    *
    * dispatches api call event (CE_API_CALL)
    * @param data {object} api call event data
    * @memberof org.ekstep.services.telemetryService
    *
    */
    apiCall: function(data) {
        if (!this.hasRequiredData(data, this.apiCallRequiredFields)) {
            console.error('Invalid api call data');
            return;
        }
        this._dispatch(this.getEvent('CE_API_CALL', data))
    },
    /**
    *
    * returns client machine info such as OS, browser, browser version
    * @memberof org.ekstep.services.telemetryService
    *
    */
    detectClient: function() {        

        var nAgt = navigator.userAgent;
        var browserName = navigator.appName;
        var fullVersion = '' + parseFloat(navigator.appVersion);
        var nameOffset, verOffset, ix;

        // In Opera
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((verOffset = nAgt.indexOf("Opera")) != -1) {
            browserName = "opera";
            fullVersion = nAgt.substring(verOffset + 6);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In MSIE
        else if ((verOffset = nAgt.indexOf("MSIE")) != -1) {
            browserName = "IE";
            fullVersion = nAgt.substring(verOffset + 5);
        }
        // In Chrome
        else if ((verOffset = nAgt.indexOf("Chrome")) != -1) {
            browserName = "chrome";
            fullVersion = nAgt.substring(verOffset + 7);
        }
        // In Safari
        else if ((verOffset = nAgt.indexOf("Safari")) != -1) {
            browserName = "safari";
            fullVersion = nAgt.substring(verOffset + 7);
            if ((verOffset = nAgt.indexOf("Version")) != -1)
                fullVersion = nAgt.substring(verOffset + 8);
        }
        // In Firefox
        else if ((verOffset = nAgt.indexOf("Firefox")) != -1) {
            browserName = "firefox";
            fullVersion = nAgt.substring(verOffset + 8);
        }
        
        // trim the fullVersion string at semicolon/space if present
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(";")) != -1)
            fullVersion = fullVersion.substring(0, ix);
        /* istanbul ignore next. Cannot test this as the test cases runs in phatomjs browser */
        if ((ix = fullVersion.indexOf(" ")) != -1)
            fullVersion = fullVersion.substring(0, ix);

        return { browser: browserName, browserver: fullVersion, os: navigator.platform };
    }
}));

org.ekstep.contenteditor.IDispatcher = Class.extend({
    init: function() {
        this.initDispatcher();
    },
    initDispatcher: function() {throw 'Subclass should implement initDispatcher'},
    dispatch: function(event) {throw 'Subclass should implement dispatch'}
});
org.ekstep.contenteditor.consoleDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "consoleDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {
        console.log(event);
    }
}));

org.ekstep.contenteditor.localDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "localDispatcher",
    initDispatcher: function() {},
    dispatch: function(event) {        
        event = (typeof event === "string") ? event : JSON.stringify(event);
        org.ekstep.contenteditor.jQuery.ajax({
            type: 'POST',
            url: 'telemetry',
            data: {event: event},
            success: function(res) {}
        });
    }
}));

org.ekstep.contenteditor.piwikDispatcher = new(org.ekstep.contenteditor.IDispatcher.extend({
    type: "piwikDispatcher",
    piwikEndPoint: function() {
        return org.ekstep.contenteditor.config.baseURL + "/piwik/piwik.php";
    },
    idsite: 1,
    initDispatcher: function() {},
    dispatch: function(event) {
        if (!event) return;

        try {
            event = (typeof event === "string") ? event : JSON.stringify(event);
            /* istanbul ignore next. Cannot test jquery post */
            org.ekstep.contenteditor.jQuery.post(this.piwikEndPoint(), 'idsite=' + this.idsite + '&url=' + org.ekstep.contenteditor.config.absURL + location.pathname + '&e_c=ContentEditor&e_a=' + event + '&rec=1', function() {
            })
            .fail(function() {
                console.log("error: while piwik dispatch");
            });
        } catch (e) {
            console.log('error: piwik event cannot be stringify', e);
        }
    }
}));

/**
 * @author Santhosh Vasabhaktula <santhosh@ilimi.in>
 */
'use strict';

angular.module('editorApp', ['ngDialog', 'oc.lazyLoad', 'Scope.safeApply']).config(['$locationProvider', function($locationProvider) {
    $locationProvider.html5Mode({
        enabled: true,
        requireBase: false
    });
}]);
angular.module('editorApp').controller('MainCtrl', ['$scope', '$ocLazyLoad',
    function($scope, $ocLazyLoad) {
        
        org.ekstep.contenteditor.init({}, {}, $scope, undefined, function() {
            $scope.contentService = org.ekstep.contenteditor.api.getService(ServiceConstants.CONTENT_SERVICE);            
            $scope.popupService = org.ekstep.contenteditor.api.getService(ServiceConstants.POPUP_SERVICE);            
        });    

        $scope.loadNgModules = function(templatePath, controllerPath) {
            var files = [];
            if (templatePath) files.push({ type: 'html', path: templatePath });
            if (controllerPath) files.push({ type: 'js', path: controllerPath });
            if (files.length) return $ocLazyLoad.load(files)
        };    

        org.ekstep.contenteditor.containerManager.initialize({loadNgModules: $scope.loadNgModules, scope: $scope });
        org.ekstep.collectioneditor.metaPageManager.initialize({loadNgModules: $scope.loadNgModules });

        // container scope starts
        $scope.editorContainer = undefined;
        $scope.addToContainer = function(container) {
            $scope.editorContainer = container;
            $scope.$safeApply();            
        }
        // container scope ends

        document.title = 'Collection-Editor';        
    }
]);

angular.module('editorApp').controller('popupController', ['ngDialog', '$ocLazyLoad', function(ngDialog, $ocLazyLoad) {
    function loadNgModules(templatePath, controllerPath) {
        return $ocLazyLoad.load([
            { type: 'html', path: templatePath },
            { type: 'js', path: controllerPath }
        ])
    };

    function openModal(config, callback) {
        if (config && callback) config.preCloseCallback = callback;
        if (config) ngDialog.open(config);
    };

    org.ekstep.contenteditor.api.getService('popup').initService(loadNgModules, openModal);

}]);
